
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="LooperXX's homepage">
      
      
      
        <meta name="author" content="Looper - Xiao Xu">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.0.2">
    
    
      
        <title>08 Machine Translation, Sequence-to-sequence and Attention - Science is interesting.</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.38780c08.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f72e892.min.css">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
        
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-164217558-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview",document.location.pathname)})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="preference" data-md-color-primary="" data-md-color-accent="">
      
        <script>matchMedia("(prefers-color-scheme: dark)").matches&&document.body.setAttribute("data-md-color-scheme","slate")</script>
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#lecture-08-machine-translation-sequence-to-sequence-and-attention" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="Science is interesting." class="md-header-nav__button md-logo" aria-label="Science is interesting.">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Science is interesting.
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              08 Machine Translation, Sequence-to-sequence and Attention
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/LooperXX/LooperXX.github.io/" title="前往 GitHub 仓库" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    LooperXX/LooperXX.github.io
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href=".." class="md-tabs__link">
        Homepage
      </a>
    
  </li>

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../Attention/" class="md-tabs__link">
          Notes
        </a>
      
    </li>
  

  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../CS224n-2019%20%E7%AE%80%E4%BB%8B/" class="md-tabs__link md-tabs__link--active">
          Notes on CS224n
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../MkDocs_demo/" class="md-tabs__link">
          For MkDocs
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Science is interesting." class="md-nav__button md-logo" aria-label="Science is interesting.">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Science is interesting.
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/LooperXX/LooperXX.github.io/" title="前往 GitHub 仓库" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    LooperXX/LooperXX.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." class="md-nav__link">
      Homepage
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Notes
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Notes" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon"></span>
        Notes
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-1" type="checkbox" id="nav-2-1">
    
    <label class="md-nav__link" for="nav-2-1">
      Theory
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Theory" data-md-level="2">
      <label class="md-nav__title" for="nav-2-1">
        <span class="md-nav__icon md-icon"></span>
        Theory
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Attention/" class="md-nav__link">
      Attention
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Normalization/" class="md-nav__link">
      Normalization
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-2" type="checkbox" id="nav-2-2">
    
    <label class="md-nav__link" for="nav-2-2">
      Code
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Code" data-md-level="2">
      <label class="md-nav__title" for="nav-2-2">
        <span class="md-nav__icon md-icon"></span>
        Code
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Notes%20on%20NCRF%2B%2B/" class="md-nav__link">
      NCRF++
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-3" type="checkbox" id="nav-2-3">
    
    <label class="md-nav__link" for="nav-2-3">
      Book
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Book" data-md-level="2">
      <label class="md-nav__title" for="nav-2-3">
        <span class="md-nav__icon md-icon"></span>
        Book
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Neural%20Reading%20Comprehension%20and%20beyond/" class="md-nav__link">
      Machine Reading Comprehension
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../NLP%20Concepts/" class="md-nav__link">
      Some Concepts
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../NNDL%20exercise/" class="md-nav__link">
      NNDL exercise
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Notes on CS224n
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Notes on CS224n" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon"></span>
        Notes on CS224n
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019%20%E7%AE%80%E4%BB%8B/" class="md-nav__link">
      CS224n-2019 Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-Assignment/" class="md-nav__link">
      CS224n-2019 Assignment
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-01-Introduction%20and%20Word%20Vectors/" class="md-nav__link">
      01 Introduction and Word Vectors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-02-Word%20Vectors%202%20and%20Word%20Senses/" class="md-nav__link">
      02 Word Vectors 2 and Word Senses
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-03-Word%20Window%20Classification%2CNeural%20Networks%2C%20and%20Matrix%20Calculus/" class="md-nav__link">
      03 Word Window Classification,Neural Networks, and Matrix Calculus
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-04-Backpropagation%20and%20Computation%20Graphs/" class="md-nav__link">
      04 Backpropagation and Computation Graphs
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-05-Linguistic%20Structure%20Dependency%20Parsing/" class="md-nav__link">
      05 Linguistic Structure Dependency Parsing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-06-The%20probability%20of%20a%20sentence%20Recurrent%20Neural%20Networks%20and%20Language%20Models/" class="md-nav__link">
      06 The probability of a sentence Recurrent Neural Networks and Language Models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-07-Vanishing%20Gradients%20and%20Fancy%20RNNs/" class="md-nav__link">
      07 Vanishing Gradients and Fancy RNNs
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        08 Machine Translation, Sequence-to-sequence and Attention
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      08 Machine Translation, Sequence-to-sequence and Attention
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#lecture-08-machine-translation-sequence-to-sequence-and-attention" class="md-nav__link">
    Lecture 08 Machine Translation, Sequence-to-sequence and Attention
  </a>
  
    <nav class="md-nav" aria-label="Lecture 08 Machine Translation, Sequence-to-sequence and Attention">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#section-1-pre-neural-machine-translation" class="md-nav__link">
    Section 1: Pre-Neural Machine Translation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#section-2-neural-machine-translation" class="md-nav__link">
    Section 2: Neural Machine Translation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#section-3-attention" class="md-nav__link">
    Section 3: Attention
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notes-06-neural-machine-translation-seq2seq-and-attention" class="md-nav__link">
    Notes 06 Neural Machine Translation, Seq2seq and Attention
  </a>
  
    <nav class="md-nav" aria-label="Notes 06 Neural Machine Translation, Seq2seq and Attention">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-neural-machine-translation-with-seq2seq" class="md-nav__link">
    1 Neural Machine Translation with Seq2Seq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-attention-mechanism" class="md-nav__link">
    2 Attention Mechanism
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-other-models" class="md-nav__link">
    3 Other Models
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-sequence-model-decoders" class="md-nav__link">
    4 Sequence model decoders
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-evaluation-of-machine-translation-systems" class="md-nav__link">
    5 Evaluation of Machine Translation Systems
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-dealing-with-the-large-output-vocabulary" class="md-nav__link">
    6 Dealing with the large output vocabulary
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7-word-and-character-based-models" class="md-nav__link">
    7 Word and character-based models
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reference" class="md-nav__link">
    Reference
  </a>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-09-Practical%20Tips%20for%20Final%20Projects/" class="md-nav__link">
      09 Practical Tips for Final Projects
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-10-Question%20Answering%20and%20the%20Default%20Final%20Project/" class="md-nav__link">
      10 Question Answering and the Default Final Project
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-11-ConvNets%20for%20NLP/" class="md-nav__link">
      11 ConvNets for NLP
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-12-Information%20from%20parts%20of%20words%20Subword%20Models/" class="md-nav__link">
      12 Information from parts of words Subword Models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-13-Modeling%20contexts%20of%20use%20Contextual%20Representations%20and%20Pretraining/" class="md-nav__link">
      13 Modeling contexts of use Contextual Representations and Pretraining
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-14-Transformers%20and%20Self-Attention%20For%20Generative%20Models/" class="md-nav__link">
      14 Transformers and Self-Attention For Generative Models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-15-Natural%20Language%20Generation/" class="md-nav__link">
      15 Natural Language Generation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-16-Coreference%20Resolution/" class="md-nav__link">
      16 Coreference Resolution
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-17-Multitask%20Learning/" class="md-nav__link">
      17 Multitask Learning
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-18-Tree%20Recursive%20Neural%20Networks%2C%20Constituency%20Parsing%2C%20and%20Sentiment/" class="md-nav__link">
      18 Tree Recursive Neural Networks, Constituency Parsing, and Sentiment
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-19-Safety%2C%20Bias%2C%20and%20Fairness/" class="md-nav__link">
      19 Safety, Bias, and Fairness
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CS224n-2019-20-The%20Future%20of%20NLP%20%2B%20Deep%20Learning/" class="md-nav__link">
      20 The Future of NLP + Deep Learning
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      For MkDocs
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="For MkDocs" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        For MkDocs
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../MkDocs_demo/" class="md-nav__link">
      Demo
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Material%20Theme%20Tutorial/" class="md-nav__link">
      Material Theme Tutorial
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#lecture-08-machine-translation-sequence-to-sequence-and-attention" class="md-nav__link">
    Lecture 08 Machine Translation, Sequence-to-sequence and Attention
  </a>
  
    <nav class="md-nav" aria-label="Lecture 08 Machine Translation, Sequence-to-sequence and Attention">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#section-1-pre-neural-machine-translation" class="md-nav__link">
    Section 1: Pre-Neural Machine Translation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#section-2-neural-machine-translation" class="md-nav__link">
    Section 2: Neural Machine Translation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#section-3-attention" class="md-nav__link">
    Section 3: Attention
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notes-06-neural-machine-translation-seq2seq-and-attention" class="md-nav__link">
    Notes 06 Neural Machine Translation, Seq2seq and Attention
  </a>
  
    <nav class="md-nav" aria-label="Notes 06 Neural Machine Translation, Seq2seq and Attention">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-neural-machine-translation-with-seq2seq" class="md-nav__link">
    1 Neural Machine Translation with Seq2Seq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-attention-mechanism" class="md-nav__link">
    2 Attention Mechanism
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-other-models" class="md-nav__link">
    3 Other Models
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-sequence-model-decoders" class="md-nav__link">
    4 Sequence model decoders
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-evaluation-of-machine-translation-systems" class="md-nav__link">
    5 Evaluation of Machine Translation Systems
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-dealing-with-the-large-output-vocabulary" class="md-nav__link">
    6 Dealing with the large output vocabulary
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7-word-and-character-based-models" class="md-nav__link">
    7 Word and character-based models
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reference" class="md-nav__link">
    Reference
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/LooperXX/LooperXX.github.io/edit/master/docs/CS224n-2019-08-Machine Translation, Sequence-to-sequence and Attention.md" title="编辑此页" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>08 Machine Translation, Sequence-to-sequence and Attention</h1>
                
                <h2 id="lecture-08-machine-translation-sequence-to-sequence-and-attention">Lecture 08 Machine Translation, Sequence-to-sequence and Attention<a class="headerlink" href="#lecture-08-machine-translation-sequence-to-sequence-and-attention" title="Permanent link">&para;</a></h2>
<p><strong>Lecture Plan</strong></p>
<ul>
<li>引入新任务：机器翻译</li>
<li>引入一种新的神经结构：sequence-to-sequence<ul>
<li>机器翻译是sequence-to-sequence的一个主要用例</li>
</ul>
</li>
<li>引入一种新的神经技术：注意力<ul>
<li>sequence-to-sequence通过attention得到提升</li>
</ul>
</li>
</ul>
<h3 id="section-1-pre-neural-machine-translation">Section 1: Pre-Neural Machine Translation<a class="headerlink" href="#section-1-pre-neural-machine-translation" title="Permanent link">&para;</a></h3>
<p><strong>Machine Translation</strong></p>
<p>机器翻译(MT)是将一个句子 x 从一种语言( <strong>源语言</strong> )转换为另一种语言( <strong>目标语言</strong> )的句子 y 的任务。</p>
<p><img alt="1561084448114" src="../imgs/1561084448114.png" /></p>
<p><strong>1950s: Early Machine Translation</strong></p>
<p>机器翻译研究始于20世纪50年代初。</p>
<ul>
<li>俄语 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 英语(冷战的推动)</li>
<li>系统主要是基于规则的，使用双语词典来讲俄语单词映射为对应的英语部分</li>
</ul>
<p><strong>1990s-2010s: Statistical Machine Translation</strong></p>
<ul>
<li><u>核心想法</u>：从数据中学习概率模型。</li>
<li>假设我们正在翻译法语 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 英语。</li>
<li>我们想要找到最好的英语句子 y ，给定法语句子 x </li>
</ul>
<div>
<div class="MathJax_Preview">
argmax_yP(y|x)
</div>
<script type="math/tex; mode=display">
argmax_yP(y|x)
</script>
</div>
<ul>
<li>使用Bayes规则将其分解为两个组件从而分别学习</li>
</ul>
<div>
<div class="MathJax_Preview">
argmax_yP(x|y)P(y)
</div>
<script type="math/tex; mode=display">
argmax_yP(x|y)P(y)
</script>
</div>
<ul>
<li><span><span class="MathJax_Preview">P(x|y)</span><script type="math/tex">P(x|y)</script></span> <ul>
<li>翻译模型</li>
<li>分析单词和短语应该如何翻译(逼真)</li>
<li>从并行数据中学习</li>
</ul>
</li>
<li>
<p><span><span class="MathJax_Preview">P(y)</span><script type="math/tex">P(y)</script></span> </p>
<ul>
<li>语言模型</li>
<li>模型如何写出好英语(流利)</li>
<li>从单语数据中学习</li>
</ul>
</li>
<li>
<p><u>问题</u>：如何学习翻译模型 <span><span class="MathJax_Preview">P(x|y)</span><script type="math/tex">P(x|y)</script></span></p>
</li>
<li>首先，需要大量的并行数据(例如成对的人工翻译的法语/英语句子)</li>
</ul>
<p><strong>Learning alignment for SMT</strong></p>
<ul>
<li><u>问题</u>：如何从并行语料库中学习翻译模型 <span><span class="MathJax_Preview">P(x|y)</span><script type="math/tex">P(x|y)</script></span></li>
<li>进一步分解:我们实际上想要考虑</li>
</ul>
<div>
<div class="MathJax_Preview">
P(x,a|y)
</div>
<script type="math/tex; mode=display">
P(x,a|y)
</script>
</div>
<ul>
<li><span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> 是对齐，即法语句子 x 和英语句子 y 之间的单词级对应</li>
</ul>
<p><strong>What is alignment?</strong></p>
<p>对齐是翻译句子中特定词语之间的对应关系。</p>
<ul>
<li>注意：有些词没有对应词</li>
</ul>
<p><img alt="1561085294365" src="../imgs/1561085294365.png" /></p>
<p><strong>Alignment is complex</strong></p>
<p>对齐可以是多对一的</p>
<p><img alt="1561085319355" src="../imgs/1561085319355.png" /></p>
<p>对齐可以是一对多的</p>
<p><img alt="1561085341219" src="../imgs/1561085341219.png" /></p>
<p>有些词很丰富</p>
<p><img alt="1561085385801" src="../imgs/1561085385801.png" /></p>
<p><img alt="1561085404516" src="../imgs/1561085404516.png" /></p>
<p>对齐可以是多对多(短语级)</p>
<p><img alt="1561085431218" src="../imgs/1561085431218.png" /></p>
<p><strong>Learning alignment for SMT</strong></p>
<ul>
<li>我们学习很多因素的组合，包括<ul>
<li>特定单词对齐的概率(也取决于发送位置)</li>
<li>特定单词具有特定生育率的概率(对应单词的数量)</li>
<li>等等</li>
</ul>
</li>
</ul>
<p><strong>Decoding for SMT</strong></p>
<p><strong><u>问题</u></strong> ：如何计算argmax</p>
<ul>
<li>我们可以列举所有可能的 y 并计算概率？<span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 太贵了</li>
<li>使用启发式搜索算法搜索最佳翻译，丢弃概率过低的假设</li>
<li>这个过程称为解码</li>
</ul>
<p><img alt="1561085566749" src="../imgs/1561085566749.png" /></p>
<p><img alt="1561085578462" src="../imgs/1561085578462.png" /></p>
<ul>
<li>SMT是一个巨大的研究领域</li>
<li>最好的系统非常复杂<ul>
<li>数以百计的重要细节我们还没有提到</li>
<li>系统有许多分别设计子组件工程<ul>
<li>很多功能需要设计特性来获取特定的语言现象</li>
</ul>
</li>
<li>需要编译和维护额外的资源<ul>
<li>比如等价短语表</li>
</ul>
</li>
<li>需要大量的人力来维护<ul>
<li>对于每一对语言都需要重复操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="section-2-neural-machine-translation">Section 2: Neural Machine Translation<a class="headerlink" href="#section-2-neural-machine-translation" title="Permanent link">&para;</a></h3>
<p><strong>What is Neural Machine Translation?</strong></p>
<ul>
<li>
<p>神经机器翻译是利用单个神经网络进行机器翻译的一种方法</p>
</li>
<li>
<p>神经网络架构称为sequence-to-sequence (又名seq2seq)，它包含两个RNNs</p>
</li>
</ul>
<p><strong>Neural Machine Translation (NMT)</strong></p>
<p><img alt="1561085889832" src="../imgs/1561085889832.png" /></p>
<ul>
<li>编码器RNN生成源语句的编码<ul>
<li>源语句的编码为解码器RNN提供初始隐藏状态</li>
</ul>
</li>
<li>解码器RNN是一种以编码为条件生成目标句的语言模型</li>
<li>注意：此图显示了测试时行为 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 解码器输出作为下一步的输入</li>
</ul>
<p><strong>Sequence-to-sequence is versatile!</strong></p>
<ul>
<li>序列到序列不仅仅对MT有用</li>
<li>
<p>许多NLP任务可以按照顺序进行表达</p>
<ul>
<li>摘要(长文本 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 短文本)</li>
<li>对话(前一句话 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 下一句话)</li>
<li>解析(输入文本 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> 输出解析为序列)</li>
<li>代码生成(自然语言 <span><span class="MathJax_Preview">\to</span><script type="math/tex">\to</script></span> Python代码)</li>
</ul>
</li>
<li>
<p><strong>sequence-to-sequence</strong> 模型是 <strong>Conditional Language Model</strong> 条件语言模型的一个例子</p>
<ul>
<li>语言模型，因为解码器正在预测目标句的下一个单词 y</li>
<li>有条件的，因为它的预测也取决于源句 x</li>
</ul>
</li>
<li>NMT直接计算 <span><span class="MathJax_Preview">P(y|x)</span><script type="math/tex">P(y|x)</script></span></li>
</ul>
<div>
<div class="MathJax_Preview">
P(y | x)=P\left(y_{1} | x\right) P\left(y_{2} | y_{1}, x\right) P\left(y_{3} | y_{1}, y_{2}, x\right) \ldots P\left(y_{T} | y_{1}, \ldots, y_{T-1}, x\right)
</div>
<script type="math/tex; mode=display">
P(y | x)=P\left(y_{1} | x\right) P\left(y_{2} | y_{1}, x\right) P\left(y_{3} | y_{1}, y_{2}, x\right) \ldots P\left(y_{T} | y_{1}, \ldots, y_{T-1}, x\right)
</script>
</div>
<ul>
<li>上式中最后一项为，给定到目前为止的目标词和源句 x ，下一个目标词的概率</li>
<li><strong><u>问题</u></strong> ：如何培训NMT系统？</li>
<li><strong><u>回答</u></strong> ：找一个大的平行语料库</li>
</ul>
<p><img alt="1561086295541" src="../imgs/1561086295541.png" /></p>
<ul>
<li>​   Seq2seq被优化为一个单一的系统。反向传播运行在“端到端”中</li>
</ul>
<p><strong>Greedy decoding</strong></p>
<ul>
<li>我们了解了如何生成(或“解码”)目标句，通过对解码器的每个步骤使用 argmax</li>
</ul>
<p><img alt="1561086920417" src="../imgs/1561086920417.png" /></p>
<ul>
<li>这是贪婪解码(每一步都取最可能的单词)</li>
<li><strong>这种方法有问题吗？</strong></li>
</ul>
<p><strong>Problems with greedy decoding</strong></p>
<ul>
<li>贪婪解码没有办法撤销决定</li>
</ul>
<p><img alt="1561086971545" src="../imgs/1561086971545.png" /></p>
<ul>
<li>如何修复？</li>
</ul>
<p><strong>Exhaustive search decoding</strong></p>
<ul>
<li>
<p>理想情况下，我们想要找到一个(长度为 T )的翻译 y 使其最大化</p>
</li>
<li>
<p>我们可以尝试计算所有可能的序列 y </p>
<ul>
<li>这意味着在解码器的每一步 t ，我们跟踪 <span><span class="MathJax_Preview">V^t</span><script type="math/tex">V^t</script></span> 个可能的部分翻译，其中 <span><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span> 是 vocab 大小</li>
<li>这种 <span><span class="MathJax_Preview">O(V^T)</span><script type="math/tex">O(V^T)</script></span> 的复杂性太昂贵了！</li>
</ul>
</li>
</ul>
<p><strong>Beam search decoding</strong></p>
<ul>
<li><u>核心思想</u> ：在解码器的每一步，跟踪 k 个最可能的部分翻译(我们称之为 <strong>hypotheses 假设</strong> )<ul>
<li>k是Beam的大小(实际中大约是5到10)</li>
</ul>
</li>
</ul>
<div>
<div class="MathJax_Preview">
\operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\log P_{\mathrm{LM}}\left(y_{1}, \ldots, y_{t} | x\right)=\sum_{i=1}^{t} \log P_{\operatorname{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)
</div>
<script type="math/tex; mode=display">
\operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\log P_{\mathrm{LM}}\left(y_{1}, \ldots, y_{t} | x\right)=\sum_{i=1}^{t} \log P_{\operatorname{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)
</script>
</div>
<ul>
<li>假设 <span><span class="MathJax_Preview">y_{1}, \dots, y_{t}</span><script type="math/tex">y_{1}, \dots, y_{t}</script></span> 有一个分数，即它的对数概率<ul>
<li>分数都是负数，分数越高越好</li>
<li>我们寻找得分较高的假设，跟踪每一步的 top k 个部分翻译</li>
</ul>
</li>
<li>波束搜索 <strong>不一定能</strong> 找到最优解</li>
<li>但比穷举搜索效率高得多</li>
</ul>
<p><strong>Beam search decoding: example</strong> </p>
<p>Beam size = k = 2</p>
<p>蓝色的数字是 <span><span class="MathJax_Preview">\operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\sum_{i=1}^{t} \log P_{\operatorname{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)</span><script type="math/tex">\operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\sum_{i=1}^{t} \log P_{\operatorname{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)</script></span> 的结果</p>
<ul>
<li>计算下一个单词的概率分布</li>
<li>取前k个单词并计算分数</li>
<li>对于每一次的 k 个假设，找出最前面的 k 个单词并计算分数</li>
<li>在 <span><span class="MathJax_Preview">k^2</span><script type="math/tex">k^2</script></span> 的假设中，保留 k 个最高的分值，如 t = 2 时，保留分数最高的 hit 和 was</li>
</ul>
<p><img alt="1561087894142" src="../imgs/1561087894142.png" /></p>
<p><strong>Beam search decoding: stopping criterion</strong></p>
<ul>
<li>在贪心解码中，我们通常解码到模型产生一个 <span><span class="MathJax_Preview">\text{&lt;END&gt;}</span><script type="math/tex">\text{<END>}</script></span> 令牌<ul>
<li>例如:<span><span class="MathJax_Preview">\text{&lt;START&gt;}</span><script type="math/tex">\text{<START>}</script></span> he hit me with a pie <span><span class="MathJax_Preview">\text{&lt;END&gt;}</span><script type="math/tex">\text{<END>}</script></span></li>
</ul>
</li>
<li>在 Beam Search 解码中，不同的假设可能在不同的时间步长上产生 <span><span class="MathJax_Preview">\text{&lt;END&gt;}</span><script type="math/tex">\text{<END>}</script></span> 令牌<ul>
<li>当一个假设生成了 <span><span class="MathJax_Preview">\text{&lt;END&gt;}</span><script type="math/tex">\text{<END>}</script></span> 令牌，该假设完成</li>
<li>把它放在一边，通过 Beam Search 继续探索其他假设</li>
</ul>
</li>
<li>通常我们继续进行 Beam Search ，直到<ul>
<li>我们到达时间步长 T (其中 T 是预定义截止点)</li>
<li>我们至少有 n 个已完成的假设(其中 n 是预定义截止点)</li>
</ul>
</li>
</ul>
<p><strong>Beam search decoding: finishing up</strong></p>
<ul>
<li>我们有完整的假设列表</li>
<li>如何选择得分最高的？</li>
<li>我们清单上的每个假设 <span><span class="MathJax_Preview">y_{1}, \dots, y_{t}</span><script type="math/tex">y_{1}, \dots, y_{t}</script></span> 都有一个分数</li>
</ul>
<div>
<div class="MathJax_Preview">
\operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\log P_{\mathrm{LM}}\left(y_{1}, \ldots, y_{t} | x\right)=\sum_{i=1}^{t} \log P_{\operatorname{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)
</div>
<script type="math/tex; mode=display">
\operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\log P_{\mathrm{LM}}\left(y_{1}, \ldots, y_{t} | x\right)=\sum_{i=1}^{t} \log P_{\operatorname{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)
</script>
</div>
<ul>
<li><u>问题在于</u> ：较长的假设得分较低</li>
<li><u>修正</u> ：按长度标准化。用下式来选择top one</li>
</ul>
<div>
<div class="MathJax_Preview">
\frac{1}{t} \sum_{i=1}^{t} \log P_{\mathrm{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)
</div>
<script type="math/tex; mode=display">
\frac{1}{t} \sum_{i=1}^{t} \log P_{\mathrm{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)
</script>
</div>
<p><strong>Advantages of NMT</strong></p>
<p>与SMT相比，NMT有很多优点</p>
<ul>
<li>更好的性能<ul>
<li>更流利</li>
<li>更好地使用上下文</li>
<li>更好地使用短语相似性</li>
</ul>
</li>
<li>单个神经网络端到端优化<ul>
<li>没有子组件需要单独优化</li>
</ul>
</li>
<li>对所有语言对使用相同的方法</li>
</ul>
<p><strong>Disadvantages of NMT?</strong></p>
<p>SMT相比</p>
<ul>
<li>NMT的可解释性较差<ul>
<li>难以调试</li>
</ul>
</li>
<li>NMT很难控制<ul>
<li>例如，不能轻松指定翻译规则或指南</li>
<li>安全问题</li>
</ul>
</li>
</ul>
<p><strong>How do we evaluate Machine Translation?</strong></p>
<p><strong>BLEU (Bilingual Evaluation Understudy)</strong></p>
<ul>
<li>你将会在 Assignment 4 中看到BLEU的细节</li>
<li>BLEU将机器翻译和人工翻译(一个或多个)，并计算一个相似的分数<ul>
<li>n-gram 精度 (通常为1-4)</li>
<li>对过于短的机器翻译的加上惩罚</li>
</ul>
</li>
<li>BLEU很有用,但不完美<ul>
<li>有很多有效的方法来翻译一个句子</li>
<li>所以一个好的翻译可以得到一个糟糕的BLEU score，因为它与人工翻译的n-gram重叠较低</li>
</ul>
</li>
</ul>
<p><strong>MT progress over time</strong></p>
<p><img alt="1561102393496" src="../imgs/1561102393496.png" /></p>
<p><strong>NMT: the biggest success story of NLP Deep Learning</strong></p>
<p>神经机器翻译于2014年从边缘研究活动到2016年成为领先标准方法</p>
<ul>
<li>2014：第一篇 seq2seq 的文章发布</li>
<li>2016：谷歌翻译从 SMT 换成了 NMT</li>
<li>这是惊人的<ul>
<li>由数百名工程师历经多年打造的SMT系统，在短短几个月内就被少数工程师训练过的NMT系统超越</li>
</ul>
</li>
</ul>
<p><strong>So is Machine Translation solved?</strong></p>
<ul>
<li>不！</li>
<li>
<p>许多困难仍然存在</p>
<ul>
<li>词表外的单词处理</li>
<li>训练和测试数据之间的 <strong>领域不匹配</strong></li>
<li>在较长文本上维护上下文</li>
<li>资源较低的语言对</li>
</ul>
</li>
<li>
<p>使用常识仍然很难</p>
</li>
</ul>
<p><img alt="1561103152409" src="../imgs/1561103152409.png" /></p>
<ul>
<li>NMT在训练数据中发现偏差</li>
</ul>
<p><img alt="1561103171522" src="../imgs/1561103171522.png" /></p>
<ul>
<li>无法解释的系统会做一些奇怪的事情</li>
</ul>
<p><img alt="1561103187808" src="../imgs/1561103187808.png" /></p>
<p><strong>NMT research continues</strong></p>
<p>NMT是NLP深度学习的核心任务</p>
<ul>
<li>NMT研究引领了NLP深度学习的许多最新创新</li>
<li>2019年：NMT研究将继续蓬勃发展<ul>
<li>研究人员发现，对于我们今天介绍的普通seq2seq NMT系统，有很多、很多的改进。</li>
<li>但有一个改进是如此不可或缺</li>
</ul>
</li>
</ul>
<p><img alt="1561103279423" src="../imgs/1561103279423.png" /></p>
<h3 id="section-3-attention">Section 3: Attention<a class="headerlink" href="#section-3-attention" title="Permanent link">&para;</a></h3>
<p><strong>Sequence-to-sequence: the bottleneck problem</strong></p>
<p><img alt="1561104067334" src="../imgs/1561104067334.png" /></p>
<ul>
<li>源语句的编码需要捕获关于源语句的所有信息</li>
<li>信息瓶颈！</li>
</ul>
<p><strong>Attention</strong></p>
<ul>
<li>注意力为瓶颈问题提供了一个解决方案</li>
<li><u>核心理念</u> ：在解码器的每一步，使用 <strong>与编码器的直接连接</strong> 来专注于源序列的特定部分</li>
<li>首先我们将通过图表展示(没有方程)，然后我们将用方程展示</li>
</ul>
<p><img alt="1561104190887" src="../imgs/1561104190887.png" /></p>
<ul>
<li>将解码器部分的第一个token <span><span class="MathJax_Preview">\text{&lt;START&gt;}</span><script type="math/tex">\text{<START>}</script></span> 与源语句中的每一个时间步的隐藏状态进行 Dot Product 得到每一时间步的分数</li>
<li>通过softmax将分数转化为概率分布<ul>
<li>在这个解码器时间步长上，我们主要关注第一个编码器隐藏状态(“he”)</li>
</ul>
</li>
</ul>
<p><img alt="1561104356688" src="../imgs/1561104356688.png" /></p>
<ul>
<li>利用注意力分布对编码器的隐藏状态进行加权求和</li>
<li>注意力输出主要包含来自于受到高度关注的隐藏状态的信息</li>
</ul>
<p><img alt="1561104403007" src="../imgs/1561104403007.png" /></p>
<ul>
<li>连接的 注意力输出 与 解码器隐藏状态 ，然后用来计算 <span><span class="MathJax_Preview">\hat y_1</span><script type="math/tex">\hat y_1</script></span></li>
</ul>
<p><img alt="1561104507830" src="../imgs/1561104507830.png" /></p>
<ul>
<li>有时，我们从前面的步骤中提取注意力输出，并将其输入解码器(连同通常的解码器输入)。我们在作业4中做这个。</li>
</ul>
<p><img alt="1561104538792" src="../imgs/1561104538792.png" /></p>
<p><strong>Attention: in equations</strong></p>
<ul>
<li>我们有编码器隐藏状态 <span><span class="MathJax_Preview">h_{1}, \ldots, h_{N} \in \mathbb{R}^{h}</span><script type="math/tex">h_{1}, \ldots, h_{N} \in \mathbb{R}^{h}</script></span></li>
<li>在时间步 t 上，我们有解码器隐藏状态 <span><span class="MathJax_Preview">s_{t} \in \mathbb{R}^{h}</span><script type="math/tex">s_{t} \in \mathbb{R}^{h}</script></span></li>
<li>我们得到这一步的注意分数</li>
</ul>
<div>
<div class="MathJax_Preview">
e^{t}=\left[s_{t}^{T} \boldsymbol{h}_{1}, \ldots, \boldsymbol{s}_{t}^{T} \boldsymbol{h}_{N}\right] \in \mathbb{R}^{N}
</div>
<script type="math/tex; mode=display">
e^{t}=\left[s_{t}^{T} \boldsymbol{h}_{1}, \ldots, \boldsymbol{s}_{t}^{T} \boldsymbol{h}_{N}\right] \in \mathbb{R}^{N}
</script>
</div>
<ul>
<li>我们使用softmax得到这一步的注意分布 <span><span class="MathJax_Preview">\alpha^{t}</span><script type="math/tex">\alpha^{t}</script></span> (这是一个概率分布，和为1)</li>
</ul>
<div>
<div class="MathJax_Preview">
\alpha^{t}=\operatorname{softmax}\left(e^{t}\right) \in \mathbb{R}^{N}
</div>
<script type="math/tex; mode=display">
\alpha^{t}=\operatorname{softmax}\left(e^{t}\right) \in \mathbb{R}^{N}
</script>
</div>
<ul>
<li>我们使用 <span><span class="MathJax_Preview">\alpha^{t}</span><script type="math/tex">\alpha^{t}</script></span> 来获得编码器隐藏状态的加权和，得到注意力输出 <span><span class="MathJax_Preview">\boldsymbol{a}_{t}</span><script type="math/tex">\boldsymbol{a}_{t}</script></span></li>
</ul>
<div>
<div class="MathJax_Preview">
\boldsymbol{a}_{t}=\sum_{i=1}^{N} \alpha_{i}^{t} \boldsymbol{h}_{i} \in \mathbb{R}^{h}
</div>
<script type="math/tex; mode=display">
\boldsymbol{a}_{t}=\sum_{i=1}^{N} \alpha_{i}^{t} \boldsymbol{h}_{i} \in \mathbb{R}^{h}
</script>
</div>
<ul>
<li>最后，我们将注意输出 <span><span class="MathJax_Preview">\boldsymbol{a}_{t}</span><script type="math/tex">\boldsymbol{a}_{t}</script></span> 与解码器隐藏状态连接起来，并按照非注意seq2seq模型继续进行</li>
</ul>
<div>
<div class="MathJax_Preview">
\left[\boldsymbol{a}_{t} ; \boldsymbol{s}_{t}\right] \in \mathbb{R}^{2 h}
</div>
<script type="math/tex; mode=display">
\left[\boldsymbol{a}_{t} ; \boldsymbol{s}_{t}\right] \in \mathbb{R}^{2 h}
</script>
</div>
<p><strong>Attention is great</strong></p>
<ul>
<li>注意力显著提高了NMT性能<ul>
<li>这是非常有用的，让解码器专注于某些部分的源语句</li>
</ul>
</li>
<li>注意力解决瓶颈问题<ul>
<li>注意力允许解码器直接查看源语句；绕过瓶颈</li>
</ul>
</li>
<li>注意力帮助消失梯度问题<ul>
<li>提供了通往遥远状态的捷径</li>
</ul>
</li>
<li>注意力提供了一些可解释性<ul>
<li>通过检查注意力的分布，我们可以看到解码器在关注什么</li>
<li>我们可以免费得到(软)对齐</li>
<li>这很酷，因为我们从来没有明确训练过对齐系统</li>
<li>网络只是自主学习了对齐</li>
</ul>
</li>
</ul>
<p><strong>Attention is a general Deep Learning technique</strong></p>
<ul>
<li>我们已经看到，注意力是改进机器翻译的序列到序列模型的一个很好的方法</li>
<li><u>然而</u> ：您可以在许多体系结构(不仅仅是seq2seq)和许多任务(不仅仅是MT)中使用注意力</li>
<li>注意力的更一般定义<ul>
<li>给定一组向量 <strong>值</strong> 和一个向量 <strong>查询</strong> ，注意力是一种根据查询，计算值的加权和的技术</li>
</ul>
</li>
<li>我们有时说 query attends to the values</li>
<li>
<p>例如，在seq2seq + attention模型中，每个解码器的隐藏状态(查询)关注所有编码器的隐藏状态(值)</p>
</li>
<li>
<p>直觉</p>
<ul>
<li>加权和是值中包含的信息的选择性汇总，查询在其中确定要关注哪些值</li>
<li>注意是一种获取任意一组表示(值)的固定大小表示的方法，依赖于其他一些表示(查询)。</li>
</ul>
</li>
</ul>
<p><strong>There are several attention variants</strong></p>
<ul>
<li>
<p>我们有一些值 <span><span class="MathJax_Preview">\boldsymbol{h}_{1}, \ldots, \boldsymbol{h}_{N} \in \mathbb{R}^{d_{1}}</span><script type="math/tex">\boldsymbol{h}_{1}, \ldots, \boldsymbol{h}_{N} \in \mathbb{R}^{d_{1}}</script></span> 和一个查询 <span><span class="MathJax_Preview">s \in \mathbb{R}^{d_{2}}</span><script type="math/tex">s \in \mathbb{R}^{d_{2}}</script></span></p>
</li>
<li>
<p>注意力总是包括</p>
<ol>
<li>
<p>计算注意力得分 <span><span class="MathJax_Preview">e \in \mathbb{R}^{N}</span><script type="math/tex">e \in \mathbb{R}^{N}</script></span> （很多种计算方式）</p>
</li>
<li>
<p>采取softmax来获得注意力分布 <span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span></p>
<div>
<div class="MathJax_Preview">
\alpha=\operatorname{softmax}(\boldsymbol{e}) \in \mathbb{R}^{N}
</div>
<script type="math/tex; mode=display">
\alpha=\operatorname{softmax}(\boldsymbol{e}) \in \mathbb{R}^{N}
</script>
</div>
</li>
<li>
<p>使用注意力分布对值进行加权求和：从而得到注意输出 <span><span class="MathJax_Preview">\boldsymbol{a}</span><script type="math/tex">\boldsymbol{a}</script></span> (有时称为上下文向量)</p>
<div>
<div class="MathJax_Preview">
\boldsymbol{a}=\sum_{i=1}^{N} \alpha_{i} \boldsymbol{h}_{i} \in \mathbb{R}^{d_{1}}
</div>
<script type="math/tex; mode=display">
\boldsymbol{a}=\sum_{i=1}^{N} \alpha_{i} \boldsymbol{h}_{i} \in \mathbb{R}^{d_{1}}
</script>
</div>
</li>
</ol>
</li>
</ul>
<p><strong>Attention variants</strong></p>
<p>有几种方法可以从 <span><span class="MathJax_Preview">\boldsymbol{h}_{1}, \ldots, \boldsymbol{h}_{N} \in \mathbb{R}^{d_{1}}</span><script type="math/tex">\boldsymbol{h}_{1}, \ldots, \boldsymbol{h}_{N} \in \mathbb{R}^{d_{1}}</script></span> 计算 <span><span class="MathJax_Preview">e \in \mathbb{R}^{N}</span><script type="math/tex">e \in \mathbb{R}^{N}</script></span> 和 <span><span class="MathJax_Preview">\boldsymbol{s} \in \mathbb{R}^{d_{2}}</span><script type="math/tex">\boldsymbol{s} \in \mathbb{R}^{d_{2}}</script></span> </p>
<ul>
<li>基本的点乘注意力 <span><span class="MathJax_Preview">\boldsymbol{e}_{i}=\boldsymbol{s}^{T} \boldsymbol{h}_{i} \in \mathbb{R}</span><script type="math/tex">\boldsymbol{e}_{i}=\boldsymbol{s}^{T} \boldsymbol{h}_{i} \in \mathbb{R}</script></span><ul>
<li>注意：这里假设 <span><span class="MathJax_Preview">d_1 = d_2</span><script type="math/tex">d_1 = d_2</script></span></li>
<li>这是我们之前看到的版本</li>
</ul>
</li>
<li>乘法注意力 <span><span class="MathJax_Preview">e_{i}=s^{T} \boldsymbol{W} \boldsymbol{h}_{i} \in \mathbb{R}</span><script type="math/tex">e_{i}=s^{T} \boldsymbol{W} \boldsymbol{h}_{i} \in \mathbb{R}</script></span><ul>
<li><span><span class="MathJax_Preview">\boldsymbol{W} \in \mathbb{R}^{d_{2} \times d_{1}}</span><script type="math/tex">\boldsymbol{W} \in \mathbb{R}^{d_{2} \times d_{1}}</script></span> 是权重矩阵</li>
</ul>
</li>
<li>
<p>加法注意力 <span><span class="MathJax_Preview">e_{i}=\boldsymbol{v}^{T} \tanh \left(\boldsymbol{W}_{1} \boldsymbol{h}_{i}+\boldsymbol{W}_{2} \boldsymbol{s}\right) \in \mathbb{R}</span><script type="math/tex">e_{i}=\boldsymbol{v}^{T} \tanh \left(\boldsymbol{W}_{1} \boldsymbol{h}_{i}+\boldsymbol{W}_{2} \boldsymbol{s}\right) \in \mathbb{R}</script></span></p>
<ul>
<li>其中 <span><span class="MathJax_Preview">\boldsymbol{W}_{1} \in \mathbb{R}^{d_{3} \times d_{1}}, \boldsymbol{W}_{2} \in \mathbb{R}^{d_{3} \times d_{2}}</span><script type="math/tex">\boldsymbol{W}_{1} \in \mathbb{R}^{d_{3} \times d_{1}}, \boldsymbol{W}_{2} \in \mathbb{R}^{d_{3} \times d_{2}}</script></span> 是权重矩阵，<span><span class="MathJax_Preview">\boldsymbol{v} \in \mathbb{R}^{d_{3}}</span><script type="math/tex">\boldsymbol{v} \in \mathbb{R}^{d_{3}}</script></span> 是权重向量</li>
<li><span><span class="MathJax_Preview">d_3</span><script type="math/tex">d_3</script></span>(注意力维度)是一个超参数</li>
</ul>
</li>
<li>
<p>你们将在作业4中考虑这些的相对优势/劣势！</p>
</li>
</ul>
<p><strong>Summary of today’s lecture</strong></p>
<p><img alt="1561106188514" src="../imgs/1561106188514.png" /></p>
<h2 id="notes-06-neural-machine-translation-seq2seq-and-attention">Notes 06 Neural Machine Translation, Seq2seq and Attention<a class="headerlink" href="#notes-06-neural-machine-translation-seq2seq-and-attention" title="Permanent link">&para;</a></h2>
<p><strong>Keyphrases</strong>: Seq2Seq and Attention Mechanisms, Neural Machine Translation, Speech Processing</p>
<h3 id="1-neural-machine-translation-with-seq2seq">1 Neural Machine Translation with Seq2Seq<a class="headerlink" href="#1-neural-machine-translation-with-seq2seq" title="Permanent link">&para;</a></h3>
<p>到目前为止，我们已经处理了预测单个输出的问题：一个单词的 NER 标签，在一个句子中根据前面的单词来预测下一个最可能的单词，等等。然而有一类的 NLP 任务是依赖序列输出的，或者输出是长度变化的序列。例如：</p>
<ul>
<li><strong>Translation</strong> ：将一种语言的一个句子作为输入，然后输出是另外一种语言的相同的意思的句子。</li>
<li><strong>Conversation</strong> ：以陈述或问题作为输入并作出回应。</li>
<li><strong>Summarization</strong> ：将大量文本作为输入并输出其摘要。</li>
</ul>
<p>在下面的部分，我们将介绍 Seq2Seq 模型，一个用来处理上述问题的深度学习框架。这个框架被证明了是非常有效的，在不到三年的时间里成为了机器翻译的标准方法。</p>
<p><strong>1.1 Brief Note on Historical Approaches</strong></p>
<p>在过去，翻译系统是基于概率模型构建的</p>
<ul>
<li>一个 <strong>翻译模型</strong> ，告诉我们一个源语言中最有可能被翻译为的句子/短语。</li>
<li>一个 <strong>语言模型</strong> ，告诉我们给定句子/短语的整体可能性。</li>
</ul>
<p>这些组成部分用于构建基于单词或短语的翻译系统。正如你所想到的，一个简单的的基于单词的翻译系统将完全不能捕获语言之间的排序差异（例如，否定词移动，句子中的主语和动词的位置等）。</p>
<p>基于短语的翻译系统在 Seq2Seq 之前是非常常见的。基于短语的翻译系统可以根据短语序列考虑输入和输出，相比比基于词的系统可以处理更复杂的语法。然而，在基于短语的翻译系统仍然难以捕获长距离的信息。</p>
<p>Seq2Seq 带来很大的优势，尤其是使用 LSTM，现代翻译系统可以在观测到整个输入后生成任意的输出序列。他们甚至可以自动地专注于输入的特定部分，以帮助生成有用的翻译。</p>
<p><strong>1.2 Sequence-to-sequence Basics</strong></p>
<p>序列到序列，或者 Seq2Seq，是一个比较新的模型，在 2014 年被提出用英语-法语翻译。在更高的层面上，Seq2Seq 是一个有两个RNN组成的端到端模型</p>
<ul>
<li>一个 encoder 编码器，将模型的输入序列作为输入，然后编码固定大小的“上下文向量”。</li>
<li>一个 decoder 解码器，使用来自编码器生成的上下文向量作为从其生成输出序列的“种子”。</li>
</ul>
<p>因此，Seq2Seq 模型通常被称为“编码器-解码器模型”。接下来我们将分别讨论这两个网络的细节。</p>
<p><strong>1.3 Seq2Seq architecture - encoder</strong></p>
<p>编码器网络的作用是读取输入序列到我们的 Seq2Seq 模型中，然后对该序列生成一个固定维度的上下文向量 <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> 。为此，编码器使用一个循环神经网络单元——一般使用 LSTM——每个时间步读取一个输入单词。单元的最终隐藏状态就是 <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> 。然而，因为将一个任意长度序列压缩到一个单一固定大小的向量是很困难的（特别是像翻译这样的困难任务），编码器通常由堆叠的 LSTM 组成：一系列 LSTM“层”，其中每层的输出是下一层的输入序列。LSTM 最后一层的最终隐藏状态就是 <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> 。</p>
<p>Seq2Seq 编码器通常会做一些奇怪的事情：它们将反向处理输入序列。实际上这么处理是有目的的。通过这样做，编码器看到的最后的信息（粗略地）对应于模型输出的开始信息；这使得解码器更容易在输出上“开始”，同时解码器也更容易地产生适当的输出句子。在翻译的环境中，我们允许网络在看到输入的前几个单词时就进行翻译；一旦前几个单词被正确地翻译，构建一个正确的句子比从头开始更加容易。</p>
<p>下图是一个展示编码器的例子，这个例子是翻译英语句子“what is your name?”注意这里是反向读取输入单词的。注意网络是展开的，每一列是一个时间步和每一行是单一层，所以水平箭头是对应隐藏状态和垂直箭头是 LSTM 的输入/输出。</p>
<p><img alt="1561110857153" src="../imgs/1561110857153.png" /></p>
<p><strong>1.4 Seq2Seq architecture - decoder</strong> </p>
<p>解码器也是一个 LSTM 网络，但是它的使用比编码器网络略微复杂。从本质上讲，我们希望它能作为一个语言模型，可以“知道”到目前为止生成的单词和输入。为此，我们将编码器保持“堆叠”的 LSTM 架构，但是我们将使用编码器生成的上下文向量来初始化第一层的隐藏层；然后编码器将使用输入的上下文向量来逐词地生成输出。</p>
<p>一旦编码器使用其上下文向量设置好，我们将传入一个特殊的字符来表示生成输出的开始。在文献中，一般是附加到输入结尾的 <span><span class="MathJax_Preview">\text{&lt;EOS&gt;}</span><script type="math/tex">\text{<EOS>}</script></span> 标记（在输出的结尾也有这样的标记，表示生成输出完成）。然后我们第一个时间步将一层接一层地运行这个三层的 LSTM，将最后一层的输出放到 softmax 函数中生成一个输出单词。然后我们把这个词传递到下一个时间步的第一层，重复上述的流程生成输出单词。这就是我们如何使 LSTM 像语言模型一样起作用。</p>
<p>下图是一个展示解码器的例子。该解码器正在解码“what is your name?”的上下文向量。注意在生成的开始使用了一个特殊的符号“GO”，而且解码的生成是按照正常的句子顺序，而不是反向读取的输入。注意输入和输出长度不需要相同。</p>
<p><img alt="1561112464274" src="../imgs/1561112464274.png" /></p>
<p>一旦我们有了输出序列，我们就像往常一样使用相同的学习策略。我们对预测序列定义一个交叉熵损失函数，然后用梯度下降算法和反向传播算法来最小化损失函数。同时对编码器和解码器进行训练，使得它们都学习到相同的上下文向量表示。</p>
<p><strong>1.5 Recap &amp; Basic NMT Example</strong></p>
<p>注意输入和输出的长度之间是没有任何联系的；模型的输入句子可以是任意长度的，模型的输出句子可以是任意长度的。然而，已经知道 Seq2Seq 模型在输入句子很长的情况下效果会变得很差，LSTM 在实际使用中有一系列的限制。</p>
<p>让我们回顾一下 Seq2Seq 模型为了将英语“what is your name?”翻译为法语“comment t’appelles tu”的例子。首先，我们从四个 one-hot 向量输入开始。这些输入需要或者不需要（对翻译任务，一般需要）用一个稠密的词向量表示。然后，一个层叠 LSTM 反向读取输入序列，将其编码为一个上下文向量。这个上下文向量是一个向量空间表示，表示“询问某人他们的名字”（输入的英文句子）的意思。我们运行这个网络的每一层的每一个时间步，对最后一层的输出放到 softmax 函数中计算，并生成我们第一个输出单词。这个单词作为网络下一个时间步的输入，并且以这种方式解码句子“comment t’appelles tu”的剩余部分。在反向传播期间，编码器的 LSTM 的权值被更新，使得它能学习到更好的句子向量表示，同时训练解码器的 LSTM 权值，使得它能生成与上下文向量相关的正确语法的句子。</p>
<p>Encoder：逐层运行，每一层的输出是下一层的输入</p>
<p>Decoder：逐时间步运行，每一个时间步的最后一层的输出是下一个时间步的第一层的输入</p>
<p><strong>1.6 Bidirectional RNNs</strong></p>
<p>之前讨论过句子的依赖不仅仅在一个方向的传播起作用；一个单词可以依赖它前面或者后面的单词。到目前为止，我们已经讨论过的 Seq2Seq 模型并没有考虑到这一点；在每个时间步，我们只是考虑当前时间步的单词的前面单词的信息（通过 LSTM 的隐藏状态）。对于 NMT，我们需要能够有效地对任意输入进行编码，而不管与输入之间的依赖关系的方向，因此这才能够让获得的信息不会减少。</p>
<p>双向RNN通过遍历序列的两个方向并连接所得到的输出（神经元输出和最终隐藏状态都进行连接）来解决这个问题。对于每个 RNN 神经元，我们简单地添加另一个神经元，但是以相反的方向向其放入输入；对应第 t 个单词的输出 <span><span class="MathJax_Preview">o_t</span><script type="math/tex">o_t</script></span> 是连接了向量 <span><span class="MathJax_Preview">\left[o_{t}^{(f)} \quad o_{t}^{(b)}\right]</span><script type="math/tex">\left[o_{t}^{(f)} \quad o_{t}^{(b)}\right]</script></span> ，其中 <span><span class="MathJax_Preview">o_{t}^{(f)}</span><script type="math/tex">o_{t}^{(f)}</script></span> 是词 t 在正向的 RNN 的输出， <span><span class="MathJax_Preview">o_{t}^{(b)}</span><script type="math/tex">o_{t}^{(b)}</script></span> 是词 t 在反向的 RNN 的输出。类似地，最终隐藏状态是 <span><span class="MathJax_Preview">\left[h^{(f)} \quad h^{(b)}\right]</span><script type="math/tex">\left[h^{(f)} \quad h^{(b)}\right]</script></span> ，其中 <span><span class="MathJax_Preview">h^{(f)}</span><script type="math/tex">h^{(f)}</script></span> 是正向的 RNN 的最终隐藏状态和 <span><span class="MathJax_Preview">h^{(b)}</span><script type="math/tex">h^{(b)}</script></span> 是反向的 RNN 的最终隐藏状态。下图是一个双向 LSTM 解码器的例子。</p>
<p><img alt="1561196418355" src="../imgs/1561196418355.png" /></p>
<h3 id="2-attention-mechanism">2 Attention Mechanism<a class="headerlink" href="#2-attention-mechanism" title="Permanent link">&para;</a></h3>
<p><strong>2.1 Motivation</strong></p>
<p>当你听到句子“the ball is on the ﬁeld”，你不会认为这 6 个单词都一样重要。你首先会注意到单词“ball”，“on” 和 “ﬁeld”，因为这些单词你是觉得最“重要”的。类似的，Bahdanau 等人注意到使用 RNN 的最终状态作为 Seq2Seq 模型的单一“上下文向量”的缺点：一般而言，输入的不同部分具有不同的重要程度。再者，此外，输出的不同部分甚至可以考虑输入的不同部分是“重要”的。例如，在翻译任务中，输出的第一个单词是一般是基于输入的前几个词，输出的最后几个词可能基于输入的几个词。</p>
<p>注意机制利用这一观察结果，为解码器网络提供了在每个解码步骤查看整个输入序列的功能；然后解码器可以在任何时间点决定哪些输入单词是重要的。有很多类型的编码器机制，但是我们将讨论由 Bahdanau 提出的机制。</p>
<p><strong>2.2 Bahdanau et al. NMT model</strong></p>
<p>再回顾一下我们的 Seq2Seq 模型是由两部分组成，一个编码器将一个输入句子编码，以及利用解码器所提取的信息生成翻译句子的解码器。基本上，我们的输入句子是一个我们想要翻译的词序列  <span><span class="MathJax_Preview">x_{1}, \ldots, x_{n}</span><script type="math/tex">x_{1}, \ldots, x_{n}</script></span> ，我们的翻译过结果（目标句子）是一个词序列 <span><span class="MathJax_Preview">y_{1}, \ldots, y_{m}</span><script type="math/tex">y_{1}, \ldots, y_{m}</script></span> 。</p>
<p><strong>Encoder</strong></p>
<ul>
<li>令 <span><span class="MathJax_Preview">\left(h_{1}, \ldots, h_{n}\right)</span><script type="math/tex">\left(h_{1}, \ldots, h_{n}\right)</script></span> 是输入句子的隐藏向量表示。这些向量是例如 bi-LSTM 的输出，并且捕获句子中每个单词的上下文表示。</li>
</ul>
<p><strong>Decoder</strong></p>
<ul>
<li>我们想使用以下形式的递归公式计算解码器的隐藏状态 <span><span class="MathJax_Preview">s_i</span><script type="math/tex">s_i</script></span></li>
</ul>
<div>
<div class="MathJax_Preview">
s_{i}=f\left(s_{i-1}, y_{i-1}, c_{i}\right)
</div>
<script type="math/tex; mode=display">
s_{i}=f\left(s_{i-1}, y_{i-1}, c_{i}\right)
</script>
</div>
<ul>
<li>
<p>其中 <span><span class="MathJax_Preview">s_{i-1}</span><script type="math/tex">s_{i-1}</script></span> 是前面的隐藏向量， <span><span class="MathJax_Preview">y_{i-1}</span><script type="math/tex">y_{i-1}</script></span> 是前面时间步生成的单词，和 <span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span> 是从原始句子捕获与解码器的时间步 <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 相关的上下文的上下文向量。</p>
</li>
<li>
<p>上下文向量 <span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span> 捕获对第 <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 个解码时间步的相关信息（与标准的的 Seq2Seq 模型只有一个上下文向量不同）。对每个原始句子的隐藏向量 <span><span class="MathJax_Preview">h_j</span><script type="math/tex">h_j</script></span> ，计算分数</p>
</li>
</ul>
<div>
<div class="MathJax_Preview">
e_{i, j}=a\left(s_{i-1}, h_{j}\right)
</div>
<script type="math/tex; mode=display">
e_{i, j}=a\left(s_{i-1}, h_{j}\right)
</script>
</div>
<ul>
<li>其中 <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> 是在 <span><span class="MathJax_Preview">\mathbb{R}</span><script type="math/tex">\mathbb{R}</script></span> 中具有值的任意函数，例如是一个单层的全连接神经网络。然后，我们得到一系列标量值 <span><span class="MathJax_Preview">e_{i, 1}, \ldots, e_{i, n}</span><script type="math/tex">e_{i, 1}, \ldots, e_{i, n}</script></span> 。然后，使用 softmax 层对这些分数进行归一化，得到向量 <span><span class="MathJax_Preview">\alpha_{i}=\left(\alpha_{i, 1}, \ldots, \alpha_{i, n}\right)</span><script type="math/tex">\alpha_{i}=\left(\alpha_{i, 1}, \ldots, \alpha_{i, n}\right)</script></span> </li>
</ul>
<div>
<div class="MathJax_Preview">
\alpha_{i, j}=\frac{\exp \left(e_{i, j}\right)}{\sum_{k=1}^{n} \exp \left(e_{i, k}\right)}
</div>
<script type="math/tex; mode=display">
\alpha_{i, j}=\frac{\exp \left(e_{i, j}\right)}{\sum_{k=1}^{n} \exp \left(e_{i, k}\right)}
</script>
</div>
<ul>
<li>然后，计算原始句子的隐藏向量与注意力向量的加权平均值作为上下向量  <span><span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script></span></li>
</ul>
<div>
<div class="MathJax_Preview">
c_{i}=\sum_{j=1}^{n} \alpha_{i, j} h_{j}
</div>
<script type="math/tex; mode=display">
c_{i}=\sum_{j=1}^{n} \alpha_{i, j} h_{j}
</script>
</div>
<ul>
<li>直观上看，该向量从原始句子的解码器的第 <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 个时间步中捕获相关的上下文信息。</li>
</ul>
<p><strong>2.3 Connection with translation alignment</strong></p>
<p>基于注意力的模型为输出的每个时间步分配对输入的不同部分的显着性（“重要性”）。在翻译任务中，注意力可以认为是“对齐”。Bahdanau 等人认为在解码的时间步 <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 中的注意力分数 <span><span class="MathJax_Preview">\alpha_{ij}</span><script type="math/tex">\alpha_{ij}</script></span> 表示源句子中的单词对齐目标句子中的单词 <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>。注意到这一点，我们可以使用注意力分数来构建一个对齐表——这个表是将源句子中的单词映射到目标句子中的相应单词——基于从我们从 Seq2Seq NMT 系统中学习到的编码器和解码器。下图是一个对齐表的例子：</p>
<p><img alt="1561197254477" src="../imgs/1561197254477.png" /></p>
<p><strong>2.4 Performance on long sentences</strong></p>
<p>基于注意力模型的主要优点是能够有效地翻译长句。当句子的输入长度变大时，模型如果只使用最终隐藏状态表示而不使用注意机制，这会丢失信息和降低准确度。注意力机制是一个聪明的方式来解决这个问题，并且现在很多实验也证实了确实如此。下图是长句子在不同的 NMT 模型中的表现</p>
<p><img alt="1561197328675" src="../imgs/1561197328675.png" /></p>
<h3 id="3-other-models">3 Other Models<a class="headerlink" href="#3-other-models" title="Permanent link">&para;</a></h3>
<p><strong>3.1 Luong et al. NMT model</strong></p>
<p>Luong 等人在论文 《Effective Approaches to Attention-based Neural Machine Translation》 提出了一个注意力机制模型的变体，是由两个不同的注意力机制组成。</p>
<p><strong>Global attention</strong> ：我们运行简单的 Seq2Seq NMT。我们称编码器的隐藏状态 <span><span class="MathJax_Preview">h_{1}, \ldots, h_{n}</span><script type="math/tex">h_{1}, \ldots, h_{n}</script></span> ，解码器的隐藏状态 <span><span class="MathJax_Preview">\overline{h}_{1}, \ldots, \overline{h}_{n}</span><script type="math/tex">\overline{h}_{1}, \ldots, \overline{h}_{n}</script></span> 。现在对每个 <span><span class="MathJax_Preview">\overline{h}_{i}</span><script type="math/tex">\overline{h}_{i}</script></span> ，我们计算编码器的隐藏状态的注意力向量。我们可以使用下面其中一个得分函数：</p>
<div>
<div class="MathJax_Preview">
\operatorname{score}\left(h_{i}, \overline{h}_{j}\right)=\left\{\begin{array}{l}{h_{i}^{T} \overline{h}_{j}} \\ {h_{i}^{T} W \overline{h}_{j} \quad \in \mathbb{R}} \\ {W\left[h_{i}, \overline{h}_{j}\right]}\end{array}\right.
</div>
<script type="math/tex; mode=display">
\operatorname{score}\left(h_{i}, \overline{h}_{j}\right)=\left\{\begin{array}{l}{h_{i}^{T} \overline{h}_{j}} \\ {h_{i}^{T} W \overline{h}_{j} \quad \in \mathbb{R}} \\ {W\left[h_{i}, \overline{h}_{j}\right]}\end{array}\right.
</script>
</div>
<ul>
<li>现在我们有一个分数的向量，然后可以用 Bahdanau 等人提出的方法来计算一个上下文向量。首先，我们通过一个 softmax 层来对分数进行归一化，得到向量 <span><span class="MathJax_Preview">\alpha_{i}=\left(\alpha_{i, 1}, \ldots, \alpha_{i, n}\right)</span><script type="math/tex">\alpha_{i}=\left(\alpha_{i, 1}, \ldots, \alpha_{i, n}\right)</script></span></li>
</ul>
<div>
<div class="MathJax_Preview">
\alpha_{i, j}=\frac{\exp \left(\operatorname{score}\left(h_{j}, \overline{h}_{i}\right)\right)}{\sum_{k=1}^{n} \exp \left(\operatorname{score}\left(h_{k}, \overline{h}_{i}\right)\right)}
</div>
<script type="math/tex; mode=display">
\alpha_{i, j}=\frac{\exp \left(\operatorname{score}\left(h_{j}, \overline{h}_{i}\right)\right)}{\sum_{k=1}^{n} \exp \left(\operatorname{score}\left(h_{k}, \overline{h}_{i}\right)\right)}
</script>
</div>
<div>
<div class="MathJax_Preview">
c_{i}=\sum_{j=1}^{n} \alpha_{i, j} h_{j}
</div>
<script type="math/tex; mode=display">
c_{i}=\sum_{j=1}^{n} \alpha_{i, j} h_{j}
</script>
</div>
<ul>
<li>然后再计算上下文向量，我们可以使用上下文向量和隐藏状态对解码器的第 <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 个时间步计算一个新的向量</li>
</ul>
<div>
<div class="MathJax_Preview">
\tilde{h}_{i}=f\left(\left[\overline{h}_{i}, c_{i}\right]\right)
</div>
<script type="math/tex; mode=display">
\tilde{h}_{i}=f\left(\left[\overline{h}_{i}, c_{i}\right]\right)
</script>
</div>
<ul>
<li>最后一步是使用 <span><span class="MathJax_Preview">\tilde{h}_{i}</span><script type="math/tex">\tilde{h}_{i}</script></span> 来对解码器进行最终预测。为了解决覆盖问题，Luong 等人使用了一个 input-feeding 方法。注意力加权的向量 <span><span class="MathJax_Preview">\tilde{h}_{i}</span><script type="math/tex">\tilde{h}_{i}</script></span> 是作为解码器的输入，而不是最终预测。这类似于 Bahdanau 等人提出的方法，他们使用上下文向量来计算解码器的隐藏向量。</li>
</ul>
<p><strong>Local attention</strong> ：该模型预测输入序列中的对齐位置。然后，它使用以此位置为中心的窗口来计算上下文向量。这个计算耗费的计算资源是恒定的，不会随着句子的长度而暴增。</p>
<p>有很多方法来使用注意力机制</p>
<p><strong>3.2 Google’s new NMT</strong></p>
<p>简而言之，Google 最近通过提升自己的翻译系统为 NMT 做出了重大突破。不是为他们支持翻译的每一种语言维护一个完整的 Seq2Seq 模型——每种语言不是单独进行训练，而是构建一个单独系统可以翻译任意两种语言，这在数据和计算时间方面都是一个巨大的成就。这是一个 Seq2Seq 模型，它接受一个单词序列和一个指定要翻译的语言的符号作为输入。该模型使用共享参数来翻译为任何目标语言。</p>
<p><img alt="1561198090770" src="../imgs/1561198090770.png" /></p>
<p>这个新的的多语言模式不仅改善了他们的翻译表现，还能够“零数据翻译”，即使我们没有翻译的训练数据。我们也可以在两种语言之间进行翻译。例如，我们如果仅有日语-英语的翻译数据和韩语-英语的翻译数据，Google 团队发现多语言 NMT 系统对这些数据进行训练后的实际上可以产生合理的日语-韩语翻译。这个发现的重要意义在于，解码过程的部分并不是特定于语言的，而且该模型实际上维持一个了 <strong>独立于所涉及的实际语言的输入/输出句子的内部表示</strong> 。</p>
<p><strong>3.3 More advanced papers using attention</strong></p>
<ul>
<li><strong><em>Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</em></strong> <ul>
<li>这篇论文是提出单词/图像对齐的方法</li>
</ul>
</li>
<li><strong><em>Modeling Coverage for Neural Machine Translation</em></strong> <ul>
<li>他们的模型使用覆盖向量，考虑到使用注意力的历史以帮助计算将来的注意力。</li>
</ul>
</li>
<li><strong><em>Incorporating Structural Alignment Biases into an Attentional Neural Translation Model</em></strong> <ul>
<li>这篇论文通过引入其他传统语言学的思想来提高注意力表现。</li>
</ul>
</li>
</ul>
<h3 id="4-sequence-model-decoders">4 Sequence model decoders<a class="headerlink" href="#4-sequence-model-decoders" title="Permanent link">&para;</a></h3>
<p>机器翻译的另一种方法来自统计机器翻译。考虑一个计算给定原始句子 <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> 的翻译 <span><span class="MathJax_Preview">\overline{s}</span><script type="math/tex">\overline{s}</script></span> 的概率模型 <span><span class="MathJax_Preview">P(\overline{s} | s)</span><script type="math/tex">P(\overline{s} | s)</script></span> 。我们想从这个概率模型中选择概率最高的翻译 <span><span class="MathJax_Preview">\overline{s} *</span><script type="math/tex">\overline{s} *</script></span> 。换而言之，我们希望</p>
<div>
<div class="MathJax_Preview">
\overline{s} *=\arg \max _{\overline{s}} P(\overline{s} | s)
</div>
<script type="math/tex; mode=display">
\overline{s} *=\arg \max _{\overline{s}} P(\overline{s} | s)
</script>
</div>
<p>因为搜索的空间可能会非常的大，所以我们需要缩小它的大小。以下是序列模型解码器的列表（包含好的和不好的）。</p>
<p><strong>Exhaustive search</strong> ：这是最简单的思路。对每个可能的序列计算其概率，然后我们从中选择概率最高的序列。但是，搜索空间对输入的大小是呈指数级增长的，所以这个方法在很难扩展到大规模输出的情况。在这个情况的解码过程是 NP 难度的问题。</p>
<p><strong>Ancestral sampling</strong> ：在时间步 <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> ，我们计算基于时间步 <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 前面的单词的条件概率分布，并从该分布中进行抽样得到 <span><span class="MathJax_Preview">x_t</span><script type="math/tex">x_t</script></span> 。</p>
<div>
<div class="MathJax_Preview">
x_{t} \sim \mathbb{P}\left(x_{l} | x_{1}, \ldots, x_{n}\right)
</div>
<script type="math/tex; mode=display">
x_{t} \sim \mathbb{P}\left(x_{l} | x_{1}, \ldots, x_{n}\right)
</script>
</div>
<p>理论上这个技术是有效的渐进精确的。然而在实际中，这个方法的表现很差和会出现高方差。</p>
<p><strong>Greedy Search</strong> ：在每个时间步，我们选择最可能的单词，换而言之</p>
<div>
<div class="MathJax_Preview">
x_{l}=\operatorname{argmax}_{x_{l}} \mathbb{P}\left(\tilde{x}_{t} | x_{1}, \ldots, x_{n}\right)
</div>
<script type="math/tex; mode=display">
x_{l}=\operatorname{argmax}_{x_{l}} \mathbb{P}\left(\tilde{x}_{t} | x_{1}, \ldots, x_{n}\right)
</script>
</div>
<p>这种技术是有效的，但是它探索了一小部分的搜索空间，如果我们在一个时间步中出现一个错误，那么剩下的句子生成可能会受到很大的影响。</p>
<p><strong>Beam search</strong> ：这个方法是在每个时间步保持着 K 个候选单词</p>
<div>
<div class="MathJax_Preview">
\mathcal{H}_{t}=\left\{\left(x_{1}^{1}, \ldots, x_{t}^{1}\right), \ldots,\left(x_{1}^{K}, \ldots, x_{t}^{K}\right)\right\}
</div>
<script type="math/tex; mode=display">
\mathcal{H}_{t}=\left\{\left(x_{1}^{1}, \ldots, x_{t}^{1}\right), \ldots,\left(x_{1}^{K}, \ldots, x_{t}^{K}\right)\right\}
</script>
</div>
<p>通过扩展 <span><span class="MathJax_Preview">\mathcal{H}_{t}</span><script type="math/tex">\mathcal{H}_{t}</script></span> 并保持 K 个最好的候选单词来计算 <span><span class="MathJax_Preview">\mathcal{H}_{t+1}</span><script type="math/tex">\mathcal{H}_{t+1}</script></span> 。换而言之，我们在下面的集合中选择最好的 K 个序列</p>
<div>
<div class="MathJax_Preview">
\tilde{\mathcal{H}}_{t+1}=\bigcup_{k=1}^{K} \mathcal{H}_{t+1}^{\tilde{k}}
</div>
<script type="math/tex; mode=display">
\tilde{\mathcal{H}}_{t+1}=\bigcup_{k=1}^{K} \mathcal{H}_{t+1}^{\tilde{k}}
</script>
</div>
<div>
<div class="MathJax_Preview">
\mathcal{H}_{t+1}^{\tilde{k}}=\left\{\left(x_{1}^{1}, \ldots, x_{t}^{1}, v_{1}\right), \ldots,\left(x_{1}^{K}, \ldots, x_{t}^{K}, v_{|V|}\right)\right\}
</div>
<script type="math/tex; mode=display">
\mathcal{H}_{t+1}^{\tilde{k}}=\left\{\left(x_{1}^{1}, \ldots, x_{t}^{1}, v_{1}\right), \ldots,\left(x_{1}^{K}, \ldots, x_{t}^{K}, v_{|V|}\right)\right\}
</script>
</div>
<p>随着增加 K 的增加，我们获得了准确率和渐近地精确。然而，提高并不具有单调性，所以我们要设置一个 K，既要考虑合理性能又要考虑计算效率。正因为如此，beam search 是在 NMT 中最常见的方法。</p>
<h3 id="5-evaluation-of-machine-translation-systems">5 Evaluation of Machine Translation Systems<a class="headerlink" href="#5-evaluation-of-machine-translation-systems" title="Permanent link">&para;</a></h3>
<p>现在我们知道有关机器翻译系统的基础知识，我们将讨论一些评估这些模型的方法。评估翻译质量是一个非常棘手和主观的任务。在现实生活中，如果您给十个不同的翻译者提供一段相同的文字，您将获得十个不同的翻译结果。翻译在实践中是不完美和有噪声的。他们关注不同的信息，强调不同的含义。一种翻译可以保存隐喻和长期思想的完整性，而而另一种翻译可以更忠实地重构句法和风格，尝试逐字翻译。注意，这种灵活性并不是负担；这证明了语言的复杂性和我们解码和解释意思的能力，也是我们交流能力的一个奇妙方面。</p>
<p>在这一点上，应该注意的是，模型的目标损失函数与我们将要讨论的评估方法之间存在差异。由于损失函数本质上是对模型预测的一个评估，所以很容易混淆这两个概念。前面的评估指标针对一些度量标准为模型提供了一个最终的、总结性的评价，没有一个度量方法优于所有其他方法，虽然有些具有明显的优势和多数偏好。</p>
<p>评估机器学习翻译的质量已经自成体系为一个研究领域，已经提出了许多评估的方法 <strong>TER, METEOR, MaxSim, SEPIA 和 RTE-MT</strong> 。我们将重点关注两个基准评估方法和 BLEU。</p>
<p><strong>5.1 Human Evaluation</strong></p>
<p>第一个也是最不令人惊讶的方法是让人们手动评估系统的正确性、充分性和流畅性。就像图灵测试一样，如果你能骗过一个人，让他无法区分人工翻译和系统翻译，那么你的模型就通过了看起来像真实句子的测试！这种方法的一个明显问题是成本高且效率低，尽管它仍然是机器翻译的黄金标准。</p>
<p><strong>5.2 Evaluation against another task</strong></p>
<p>评估机器学习模型的一种常见方法是输出有用的表示数据（表示为翻译或摘要），如果您的预测对解决某些具有挑战性的任务很帮助，那么模型必须在预测中编码相关信息。例如，您可能会考虑在翻译语言的问答任务中训练翻译预测。也就是说，您使用系统的输出作为其他任务(问答)模型的输入。如果您的第二个任务在您的预测上和在翻译语言的格式良好的数据上一样出色，这意味着您的输入具有满足任务需求的相关信息或模式。</p>
<p>这种方法的问题在于，第二个任务可能不会受到许多翻译细节的影响。例如，如果您在查询检索任务中衡量翻译质量（例如，提取搜索查询的正确网页），你会发现一个翻译有助于保护文档的主题句,但忽略了语法和语法仍然可能适合的任务。但这并不意味着翻译质量是准确可靠的。因此，确定翻译模型的质量只是为了确定任务本身的质量，这可能是也可能不是一个好的标准。</p>
<p><strong>5.3 Bilingual Evaluation Understudy (BLEU)</strong></p>
<p>在 2002 年，IBM 的研究者提出了 Bilingual Evaluation Understudy（BELU），时至今日，该方法的很多变体，是机器翻译中最可靠的评估方法之一。</p>
<p>BELU 算法通过参考人工翻译来评估机器翻译的精确度分数。参考人工翻译被假定为是一个翻译的模型样例，然后我们使用 n-gram 匹配候选翻译与人工翻译之间的相似程度作为度量标注。考虑一个参考句子 A 和候选翻译 B：</p>
<p>A：there are many ways to evaluate the quality of a translation, like comparing the number of n-grams between a candidate translation and reference.</p>
<p>B：the quality of a translation is evaluate of n-grams in a reference and with translation.</p>
<p>BELU 分数是查找在机器翻译中是否有 n-grams 也出现在参考翻译中。以下彩色的翻译是参考翻译和候选翻译之间共享的不同大小的 n-grams 的一些示例。</p>
<p><img alt="1561198488562" src="../imgs/1561198488562.png" /></p>
<p><img alt="1561198494344" src="../imgs/1561198494344.png" /></p>
<p>BELU 算法通过识别上述所有的 n-grams 匹配，包括 unigram 匹配，然后用精确度分数来评估翻译的好坏。精确度分数是 n-grams 既出现在参考翻译中也出现在机器翻译中的百分比。</p>
<p>这个算法也满足其他的两个限制。对每个 n-grams 的大小，参考翻译中的 gram 不能匹配多于一次。例如，unigram “a” 在 B 中出现了两次而在 A 中只出现了一次。这只统计两个翻译句子之间匹配一次的的次数。另外，我们强加一个简单的惩罚，使得精确度分数是 1.0（“完美”匹配）的短句子不被认为是一个很好的翻译结果。例如，对单个单词 there 会得到一个精确度分数为 1.0 的匹配，但是很明显这不是一个好的匹配。</p>
<p>接下来我们看看实际中如何计算 BELU 分数。首先令 k 是我们要评估的分数的最大 n-gram 。即如果 k=4，BELU 分数仅计算大小 <span><span class="MathJax_Preview">\leq 4</span><script type="math/tex">\leq 4</script></span> 的 n-grams ，并忽略大于 4 的 n-grams 。令</p>
<div>
<div class="MathJax_Preview">
p_{n}=\# \text {matched n-grams} / \text{# n-grams in candidate translation}
</div>
<script type="math/tex; mode=display">
p_{n}=\# \text {matched n-grams} / \text{# n-grams in candidate translation}
</script>
</div>
<p>为对长度是 n 的 grams 的精确度分数。最后，令 <span><span class="MathJax_Preview">w_{n}=1 / 2^{n}</span><script type="math/tex">w_{n}=1 / 2^{n}</script></span> 是第 n 个 gram 的几何加权。我们简单惩罚的定义为</p>
<div>
<div class="MathJax_Preview">
\beta=e^{\min \left(0,1-\frac{len_{ref}}{len_{MT}}\right)}
</div>
<script type="math/tex; mode=display">
\beta=e^{\min \left(0,1-\frac{len_{ref}}{len_{MT}}\right)}
</script>
</div>
<p>其中 <span><span class="MathJax_Preview">len_{ref}</span><script type="math/tex">len_{ref}</script></span> 是参考翻译的句子长度， <span><span class="MathJax_Preview">len_{MT}</span><script type="math/tex">len_{MT}</script></span> 是机器翻译的句子长度。</p>
<p>BELU 分数然后定义为：</p>
<div>
<div class="MathJax_Preview">
B E L U=\beta \prod_{i=1}^{k} p_{n}^{w_{n}}
</div>
<script type="math/tex; mode=display">
B E L U=\beta \prod_{i=1}^{k} p_{n}^{w_{n}}
</script>
</div>
<p>BLEU 评分与人类对优秀翻译的判断密切相关，因此仍然是所有评估指标的基准。然而，它还是有许多限制的。它只能在语料库级别上工作得很好，因为精度得分中的任何零都将使整个BLEU得分为零。另外，BLEU 得分仅仅将机器翻译与单个人工翻译进行比较，这肯定需要匹配相关的 n-grams 的噪声表示。BLEU 的变体已经将这个算法修改为可以将候选机器翻译与多个人工翻译进行比较。此外，BLEU分数可能只是一个必要的，但并不足以通过一个良好的机器翻译系统的基准。许多研究人员对 BLEU 的分数进行了优化，直到他们开始接近参考译文之间相同的BLEU分数，但真正的质量仍然远远低于人类译文。</p>
<h3 id="6-dealing-with-the-large-output-vocabulary">6 Dealing with the large output vocabulary<a class="headerlink" href="#6-dealing-with-the-large-output-vocabulary" title="Permanent link">&para;</a></h3>
<p>尽管现代的 NMT 系统取得了成功，但是他们很难处理大量的词汇量。特别地，这些 Seq2Seq 模型通过使用 softmax 计算整个词汇表上的目标概率分布来预测序列中的下一个单词。事实证明，使用大量词汇表来计算 softmax 可能相当耗费计算资源，而且时间复杂度也会与词汇大小成正比。我们现在将研究一些解决这个问题的方法。</p>
<p><strong>6.1 Scaling softmax</strong></p>
<p>一个非常自然的想法是问“我们能找到更有效的方法来计算目标概率分布吗？”答案是可以的！实际上，我们已经学会了两种可以降低“softmax”复杂度的方法，我们将在下面回顾一下（更多细节请看 lecture one 中的相关方法的介绍）。</p>
<p><strong>Noise Contrastive Estimation</strong></p>
<p>NCE 的想法是通过随机地从负样本中抽取 K 个单词来近似“softmax”。因此，我们将计算复杂度降低了 <span><span class="MathJax_Preview">\frac{|V|}{K}</span><script type="math/tex">\frac{|V|}{K}</script></span> 倍，其中 <span><span class="MathJax_Preview">{|V|}</span><script type="math/tex">{|V|}</script></span> 是词汇表的大小。这个方法在 word2vec 中证明了非常有效。Zoph 等人最近的一项工作是应用这种技术来学习 LSTM 语言模型，他们还通过使用每个 mini batch 的相同样本来引入一个技巧，使 GPU 的训练效率更高。</p>
<p><strong>Hierarchical Softmax</strong></p>
<p>Morin 等人提出了一个二叉树结构从而能够更有效率地计算 目标分布中的每个概率都是通过将树上的一个路径计算出来“softmax”，该计算该路径只需要 <span><span class="MathJax_Preview">O(\log |V|)</span><script type="math/tex">O(\log |V|)</script></span> 步长。值得注意的是，尽管 Hierarchical Softmax 可以节省计算量，但是它不能在 GPU 上并行运算。</p>
<p>这两种方法的一个限制是它们仅在训练阶段中节省计算量（当目标词已知时）。在测试阶段，我们还需要计算词汇表中的所有单词的概率，然后做出预测。</p>
<p><strong>6.2 Reducing vocabulary</strong></p>
<p>除了优化“softmax”，我们还可以尝试减少有效的词汇量，这将加快训练和测试过程。一种简单的方法是将词汇量限制在一个很小的数量上，用一个标签 <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span> 替换限制后的词汇表外的单词。现在，无论是训练和测试时间可以显着地降低了，但这显然是不理想的，因为我们可能会产生很多  <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span> 的输出。</p>
<p>Jean 等人提出了一种保持固定词汇大小 <span><span class="MathJax_Preview">\left|V^{\prime}\right|</span><script type="math/tex">\left|V^{\prime}\right|</script></span> 的方法， 通过将训练数据分成具有 <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span> 个唯一目标单词的子集，其中 <span><span class="MathJax_Preview">\tau=\left|V^{\prime}\right|</span><script type="math/tex">\tau=\left|V^{\prime}\right|</script></span> 。可以通过依次扫描原始数据集直到检测 <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span> 个唯一的目标单词，从而形成一个子集（如下图所示）</p>
<p><img alt="1561198801494" src="../imgs/1561198801494.png" /></p>
<p>然后按照上述过程遍历整个数据集，以产生所有的 mini-batch 子集。实际中，我们可以通过这个方法词汇量为 <span><span class="MathJax_Preview">|V|=500 K</span><script type="math/tex">|V|=500 K</script></span> 实现了 10 倍以上的节省（ <span><span class="MathJax_Preview">\left|V^{\prime}\right|=30 K, 50 K</span><script type="math/tex">\left|V^{\prime}\right|=30 K, 50 K</script></span> ）。</p>
<p>这个概念和 NCE 非常类似，对任意给定的单词，输出的词汇包含目标单词和 <span><span class="MathJax_Preview">\left|V^{\prime}\right|-1</span><script type="math/tex">\left|V^{\prime}\right|-1</script></span> 个负（噪声）样例。然而，这两个方法主要的不同是，对每个子集 <span><span class="MathJax_Preview">\left|V^{\prime}\right|</span><script type="math/tex">\left|V^{\prime}\right|</script></span> ，是从偏置分布 <span><span class="MathJax_Preview">|Q|</span><script type="math/tex">|Q|</script></span> 中采样这些负样例，其中</p>
<div>
<div class="MathJax_Preview">
\mathcal{Q}_{y_{t}}=\left\{\begin{array}{l}{\frac{1}{\left|V^{\prime}\right|}, \text { if } y_{t} \in\left|V^{\prime}\right|} \\ {0, \text { otherwise }}\end{array}\right.
</div>
<script type="math/tex; mode=display">
\mathcal{Q}_{y_{t}}=\left\{\begin{array}{l}{\frac{1}{\left|V^{\prime}\right|}, \text { if } y_{t} \in\left|V^{\prime}\right|} \\ {0, \text { otherwise }}\end{array}\right.
</script>
</div>
<p>在测试阶段，也可以从整个词汇表中选择一个子集(称为候选列表)来预测目标单词。挑战在于，正确的目标词是未知的，我们必须“猜测”目标词可能是什么。在论文中，作者提出使用 <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> 个最常用的单词（基于 unigram 概率）和 <span><span class="MathJax_Preview">K'</span><script type="math/tex">K'</script></span> 个可能的目标词为每个源句构建一个候选列表。在下图中展示了一个 <span><span class="MathJax_Preview">K^{\prime}=3</span><script type="math/tex">K^{\prime}=3</script></span> 的例子和候选列表由紫色框中的所有单词组成。在实际中，我们可以选择以下的参数值： <span><span class="MathJax_Preview">K=15 k, 30 k, 50 k, K^{\prime}=10,20</span><script type="math/tex">K=15 k, 30 k, 50 k, K^{\prime}=10,20</script></span> 。</p>
<p><img alt="1561198919712" src="../imgs/1561198919712.png" /></p>
<p><strong>6.3 Handling unknown words</strong></p>
<p>当 NMT 系统使用上面提到的方法来以降低有效词汇量，不可避免地，某些单词将被映射到 <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span>。例如，当预测词（通常是罕见词）不在候选列表中或当我们在测试阶段遇到未知的单词时，可能会发生这种情况。我们需要新的机制来解决罕见和未知的单词问题。</p>
<p>Gulcehre 等人提出了一个想法来处理这些问题：学习从源文本中“复制”。该模型应用了注意力分布 <span><span class="MathJax_Preview">l_t</span><script type="math/tex">l_t</script></span> 来决定源文本中的指向位置，并使用解码器的隐藏状态 <span><span class="MathJax_Preview">S_t</span><script type="math/tex">S_t</script></span> 来预测二分类变量 <span><span class="MathJax_Preview">Z_t</span><script type="math/tex">Z_t</script></span> ，从而决定何时从源文本中复制。</p>
<p><img alt="1561198974177" src="../imgs/1561198974177.png" /></p>
<p>最后的预测结果是根据 <span><span class="MathJax_Preview">Z_t</span><script type="math/tex">Z_t</script></span> 的值，在候选列表中由前面介绍的方法使用 softmax 选择的词 <span><span class="MathJax_Preview">y_{t}^{w}</span><script type="math/tex">y_{t}^{w}</script></span> ，或者从源文本复制的 <span><span class="MathJax_Preview">y_{t}^{l}</span><script type="math/tex">y_{t}^{l}</script></span> 。他们在论文中的结果表明，该方法提高了机器翻译和文本摘要等任务的表现。</p>
<p>然而可以想到的是，这种方法也是有局限性的。这是要重点指出的是在 Google NMT 论文中对这个方法的一个评论：“这种做法在规模很大时是不可靠的——当网络是很深的时候，注意力机制是不稳定的——而复制机制可能不是最适合处理罕见单词的策略——有时音译更合适”。</p>
<h3 id="7-word-and-character-based-models">7 Word and character-based models<a class="headerlink" href="#7-word-and-character-based-models" title="Permanent link">&para;</a></h3>
<p>如上一部分所述，“复制”机制在处理罕见或未知词语上仍然存在不足。解决这些问题的另一个思路是在 sub-word 的级别进行操作。一个趋势是使用相同的 Seq2Seq 架构，但是在更小的单元上操作——基于字符的分词模型。另一个趋势是对单词和字符采用混合架构。</p>
<p><strong>7.1 Word segmentation</strong></p>
<p>Sennrich 等人提出了一种通过将罕见和未知的单词作为一个 subword units 的序列来实现开放词汇翻译的方法。</p>
<p>这通过调整称为 <strong>Byte Pair Encoding</strong> 的压缩算法来实现。基本思想是从字符词汇表开始，并且继续扩展数据集中最常见的 n-gram 对。例如，在下图中，我们的数据集包含 4 个单词，图中的左边的表示单词频率，例如“low”出现了 5 次。用 <span><span class="MathJax_Preview">(p,q,f)</span><script type="math/tex">(p,q,f)</script></span> 来表示一个 n-gram 对 <span><span class="MathJax_Preview">p,q</span><script type="math/tex">p,q</script></span> 和出现的频率 <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> 。如图中所示，我们已经选择的频率最高的的 n-gram 对 <span><span class="MathJax_Preview">(e,s,9)</span><script type="math/tex">(e,s,9)</script></span>，然后我们现在增加当前频率最高的的 n-gram 对 <span><span class="MathJax_Preview">(es,t,9)</span><script type="math/tex">(es,t,9)</script></span> 。重复此过程，直到所有 n-gram 对被选择过或词汇大小达到某个阈值。</p>
<p><img alt="1561199106928" src="../imgs/1561199106928.png" /></p>
<p>我们可以选择为训练集和测试集构建单独的词汇表，或者共同构建一个词汇表。在构建词汇表之后，一个带有 Seq2Seq 体系结构的 NMT 系统（Bahdanau 等人在论文中使用的），可以直接训练这些词段。值得注意的是，这种方法赢得了 WMT 2016 的第一名。</p>
<p><strong>7.2 Character-based model</strong></p>
<p>Ling 等人提出了一种基于字符的模型来实现开放词汇表示。对于具有 m 个字符的每个单词 w，该模型不是存储单词的词向量，而是遍历所有字符 <span><span class="MathJax_Preview">c_{1}, c_{2} \dots c_{m}</span><script type="math/tex">c_{1}, c_{2} \dots c_{m}</script></span> 查找字符嵌入 <span><span class="MathJax_Preview">e_{1}, e_{2} \dots e_{m}</span><script type="math/tex">e_{1}, e_{2} \dots e_{m}</script></span> 。然后将这些字符嵌入作为 biLSTM 输入，以分别获得用于前向和后向的最终隐藏状态 <span><span class="MathJax_Preview">h_{f}, h_{b}</span><script type="math/tex">h_{f}, h_{b}</script></span> 。最终的词向量是由两个隐藏状态的仿射变换来计算而得：
$$
e_{w}=W_{f} H_{f}+W_{b} H_{b}+b
$$</p>
<p><strong>7.3 Hybrid NMT</strong></p>
<p>Luong 等人提出了一个混合词字模型来处理未知词，从而实现开放词汇 NMT。系统主要进行单词级翻译，并查阅罕见单词的字符组成。在高层次上，字符级循环神经网络计算源单词词表示，并在需要时重新获得未知目标单词。这种混合方法的双重优点在于，它的训练比基于字符的方法要快得多，而且更容易进行训练；同时，它不会像基于单词的模型，产生未知的单词。</p>
<p><strong>基于单词的翻译作为主干</strong> ：混合 NMT 的核心是一个单词级翻译的深度 LSTM 编码器—解码器。我们对每种语言维护大小 <span><span class="MathJax_Preview">|V|</span><script type="math/tex">|V|</script></span> 的词汇表和使用 <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span> 来表示 OOV 词汇。</p>
<p><strong>基于字符表示</strong> ：在常规的基于单词的 NMT，是使用一个通用的 <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span> 词向量来表示全部 OOV 词汇。这是有问题的，因为它丢弃了关于源单词的有价值的信息。相反，我们学习了一个关于罕见单词的字符的深层 LSTM 模型，并使用 LSTM 的最终隐藏状态作为罕见单词的表示（如下图所示）。</p>
<p><img alt="1561199114562" src="../imgs/1561199114562.png" /></p>
<p><strong>目标字符级别生成</strong> ：一般基于单词的 NMT 允许目标输出生成的 <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span> 。相反，这里的目标是创建一个处理无限输出词汇表的连贯框架。解决方案是，在给定当前单词级别的状态下，使用一个单独的深层 LSTM 来进行字符级别的“翻译”。注意，当前单词上下文用于初始化字符级编码器。该系统的训练方法是，每当单词级别的 NMT 产生一个的 <span><span class="MathJax_Preview">\text{&lt;UNK&gt;}</span><script type="math/tex">\text{<UNK>}</script></span> 时候，字符级的解码器就被要求重新未知目标单词的正确的 surface form。</p>
<h2 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">&para;</a></h2>
<p>以下是学习本课程时的可用参考书籍：</p>
<p><a href="https://item.jd.com/12355569.html">《基于深度学习的自然语言处理》</a> （车万翔老师等翻译）</p>
<p><a href="https://nndl.github.io/">《神经网络与深度学习》</a></p>
<p>以下是整理笔记的过程中参考的博客：</p>
<p><a href="https://zhuanlan.zhihu.com/p/59011576">斯坦福CS224N深度学习自然语言处理2019冬学习笔记目录</a> (课件核心内容的提炼，并包含作者的见解与建议)</p>
<p><a href="https://zhuanlan.zhihu.com/p/31977759">斯坦福大学 CS224n自然语言处理与深度学习笔记汇总</a> <span class="critic comment">这是针对note部分的翻译</span></p>
                
              
              
                


  <h2 id="__comments">评论</h2>
  <div id="disqus_thread"></div>
  <script>var disqus_config=function(){this.page.url="None",this.page.identifier="None"};window.addEventListener("load",function(){var e=document,i=e.createElement("script");i.src="//https-looperxx-github-io-my-wiki.disqus.com/embed.js",i.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(i)})</script>

              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../CS224n-2019-07-Vanishing%20Gradients%20and%20Fancy%20RNNs/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                07 Vanishing Gradients and Fancy RNNs
              </div>
            </div>
          </a>
        
        
          <a href="../CS224n-2019-09-Practical%20Tips%20for%20Final%20Projects/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                09 Practical Tips for Final Projects
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2019 - 2020 Xiao Xu
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
  <div class="md-footer-social">
    
      
      
        
        
      
      <a href="https://github.com/looperXX" target="_blank" rel="noopener" title="github.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
      </a>
    
      
      
        
        
      
      <a href="https://www.linkedin.com/in/%E5%95%B8-%E5%BE%90-012456163/" target="_blank" rel="noopener" title="www.linkedin.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
      </a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.77e55a48.min.js"></script>
      <script src="../assets/javascripts/bundle.9554a270.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: ['navigation.tabs', 'header.autohide'],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
        <script src="../js/baidu-tongji.js"></script>
      
    
  </body>
</html>